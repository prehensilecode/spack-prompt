# bash/zsh spack prompt support
#
# Based on git-prompt.sh
#
# Copyright (C) 2025 David Chin
# Distributed under the GNU General Public License, version 3.0.
#
# Copyright (C) 2006,2007 Shawn O. Pearce <spearce@spearce.org>
# Distributed under the GNU General Public License, version 2.0.
#
# This script allows you to see repository status in your prompt.
#
# To enable:
#
#    1) Copy this file to somewhere (e.g. ~/.spack-prompt.sh).
#    2) Add the following line to your .bashrc/.zshrc/.profile:
#        . ~/.spack-prompt.sh   # dot path/to/this-file
#    3a) Change your PS1 to call __spack_ps1 as
#        command-substitution:
#        Bash: PS1='$(__spack_ps1 "{%s} ")[\u@\h \W]\$ '
#        ZSH:  setopt PROMPT_SUBST ; PS1='$(__spack_ps1 "{%s} ")[%n@%m %c]\$ '
#        the optional argument will be used as format string.
#    3b) Alternatively, for a slightly faster prompt, __spack_ps1 can
#        be used for PROMPT_COMMAND in Bash or for precmd() in Zsh
#        with two parameters, <pre> and <post>, which are strings
#        you would put in $PS1 before and after the status string
#        generated by the spack-prompt machinery.  e.g.
#        Bash: PROMPT_COMMAND='__spack_ps1 "\u@\h:\w" "\\\$ "'.
#        ZSH:  precmd () { __spack_ps1 "%n" ":%~$ " "|%s" }
#        Optionally, you can supply a third argument with a printf
#        format string to finetune the output of the branch status
#

# check whether printf supports -v
__spack_printf_supports_v=
printf -v __spack_printf_supports_v -- '%s' yes >/dev/null 2>&1

# like __spack_SOH=$'\001' etc but works also in shells without $'...'
eval "$(printf '
    __spack_SOH="\001" __spack_STX="\002" __spack_ESC="\033"
    __spack_LF="\n" __spack_CRLF="\r\n"
')"

# __spack_ps1 accepts 0 or 1 arguments (i.e., format string)
# when called from PS1 using command substitution
# in this mode it prints text to add to bash PS1 prompt (includes branch name)
#
# __spack_ps1 requires 2 or 3 arguments when called from PROMPT_COMMAND (pc)
# in that case it _sets_ PS1. The arguments are parts of a PS1 string.
# when two arguments are given, the first is prepended and the second appended
# to the state string when assigned to PS1.
# The optional third parameter will be used as printf format string to further
# customize the output of the spack-status string.
__spack_ps1 ()
{
    # preserve exit status
    local exit="$?"
    local pcmode=no
    local ps1pc_start='\u@\h:\w '
    local ps1pc_end='\$ '
    local printf_format='{%s}'

    case "$#" in
        2|3)    pcmode=yes
            ps1pc_start="$1"
            ps1pc_end="$2"
            printf_format="${3:-$printf_format}"
            # set PS1 to a plain prompt so that we can
            # simply return early if the prompt should not
            # be decorated
            PS1="$ps1pc_start$ps1pc_end"
        ;;
        0|1)    printf_format="${1:-$printf_format}"
        ;;
        *)  return "$exit"
        ;;
    esac
    
    # ps1_expanded:  This variable is set to 'yes' if the shell
    # subjects the value of PS1 to parameter expansion:
    #
    #   * bash does unless the promptvars option is disabled
    #   * zsh does not unless the PROMPT_SUBST option is set
    #   * POSIX shells always do

    # Assume that the shell follows the POSIX specification and
    # expands PS1 unless determined otherwise.  (This is more
    # likely to be correct if the user has a non-bash, non-zsh
    # shell and safer than the alternative if the assumption is
    # incorrect.)
    #
    local ps1_expanded=yes
    [ -z "${ZSH_VERSION-}" ] || eval '[[ -o PROMPT_SUBST ]]' || ps1_expanded=no
    [ -z "${BASH_VERSION-}" ] || shopt -q promptvars || ps1_expanded=no

    if [ -z "$SPACK_ENV" ]; then
        return "$exit"
    fi

    local spackstring=""
    if [ ! -z ${SPACK_ENV+x} ]; then
        spackstring=$( basename $SPACK_ENV )
    fi

    if [ "$pcmode" = yes ]; then
        if [ "${__spack_printf_supports_v-}" != yes ]; then
            spackstring=$(printf -- "$printf_format" "$spackstring")
        else
            printf -v spackstring -- "$printf_format" "$spackstring"
        fi
        PS1="$ps1pc_start$spackstring$ps1pc_end"
    else
        printf -- "$printf_format" "$spackstring"
    fi

    return "$exit"
}
